<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>bww2abc - Convertisseur web</title>
  <script>
    // Charge abcjs: local (basic) d'abord, CDN en repli.
    // Local: on force le bundle "basic" (rendu partition). Audio sera dispo uniquement si on tombe sur le bundle complet via CDN.
    window.__loadAbcjsPromise = (function () {
      const CSS_HREF = '/vendor/abcjs/abcjs-audio.css';
      function ensureCss() {
        if (document.querySelector('link[data-abcjs-css]')) return;
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = CSS_HREF;
        link.setAttribute('data-abcjs-css', '');
        document.head.appendChild(link);
      }

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.onload = () => resolve(src);
          s.onerror = () => reject(new Error('Fail ' + src));
          document.head.appendChild(s);
        });
      }

      async function tryLocal() {
        // Utilise explicitement la version basic locale (présente dans node_modules/abcjs/dist)
        await loadScript('/vendor/abcjs/abcjs-basic-min.js');
      }

      async function tryCdn() {
        try {
          await loadScript('https://cdn.jsdelivr.net/npm/abcjs@6.3.0/dist/abcjs-min.js');
        } catch (_) {
          await loadScript('https://cdn.jsdelivr.net/npm/abcjs@6.3.0/dist/abcjs-basic-min.js');
        }
      }

      return (async () => {
        if (window.ABCJS) return window.ABCJS;
        try {
          await tryLocal();
        } catch (_) {
          await tryCdn();
        }
        if (!window.ABCJS) throw new Error('abcjs non chargé');
        if (typeof window.ABCJS.renderAbc !== 'function') {
          throw new Error('abcjs chargé mais API inattendue (renderAbc manquant)');
        }
        ensureCss();
        return window.ABCJS;
      })();
    })();
  </script>
  <link rel="stylesheet" href="/styles.css" />
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Convertir des fichiers <code>.bww</code> en <code>.abc</code></h1>
      <p>
        Déposez un ou plusieurs fichiers .bww ci-dessous, ou cliquez pour
        choisir.
      </p>
      <p>
        <a href="https://bagpipetunes.intertechnics.com/" target="blank">Pour choisir des fichiers bww:
          https://bagpipetunes.intertechnics.com/</a>
      </p>


      <label class="drop" id="drop">
        <strong>Glissez-déposez ici</strong>
        <span class="hint">ou</span>
        <button class="btn" id="pick">Choisir des fichiers</button>
        <input id="file" type="file" accept=".bww" multiple />
      </label>

      <div class="list" id="list"></div>

      <div class="footer">
        <button class="btn" id="convert" disabled>Convertir le lot</button>
        <button class="btn" id="reset" type="button">RAZ</button>
        <span class="hint">Les fichiers convertis seront téléchargés automatiquement (ZIP si plusieurs). RAZ vide la
          sélection.</span>
      </div>

    </div>

      <footer>
        <div>Crédits:
          <p class="hint links" style="margin-top: 10px">
            Un grand merci à Jean François Moine pour le fichier bww2abc originale :
            <a href="http://moinejf.free.fr/" target="_blank" rel="noreferrer">moinejf.free.fr</a>
          </p>
          <p class="hint links" style="margin-top: 10px">
            bww2abc.js: Copyright (C) 2018-2023 Jean-Francois Moine License GPL3+
          </p>
          <p class="hint links" style="margin-top: 10px">abcjs:  an open source ABC music notation library, written by Paul Rosen and Gregory Dyke.</p>
        </div>
      </footer>
  </div>

  <script>
    const fileInput = document.getElementById("file");
    const pickBtn = document.getElementById("pick");
    const drop = document.getElementById("drop");
    const list = document.getElementById("list");
    const convertBtn = document.getElementById("convert");
    const resetBtn = document.getElementById("reset");

    let files = [];

    const DEFAULT_SOUNDFONT_URL = 'https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/';
    const audioState = { instrument: 'bagpipe', graceFraction: 0.1 };
    let ornamentUpdateTimer = null;
    let activeSynthControl = null;
    let activeVisualObj = null;
    let activeAbcSource = '';
    let activeDownloadName = '';

    // Zone d'aperçu ABC + audio (ajoutée dynamiquement)
    const viewer = document.createElement("div");
    viewer.id = "viewer";
    viewer.style.marginTop = "20px";
    viewer.style.display = "none";
    viewer.innerHTML = `
       
        <div id=\"paper\" style=\"background:#0e1533;border-radius:10px;padding:12px;\"></div>
        <div id=\"audio-controls\" style=\"margin-top:10px;\"></div>
        <details style=\"margin-top:10px;\">
          <summary>Voir le code ABC</summary>
          <pre id=\"abc-code\" style=\"white-space:pre-wrap;color:#c8d1ff;background:#0e1533;padding:12px;border-radius:10px;\"></pre>
        </details>
        <div style=\"margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;\">
          <button class=\"btn\" id=\"download-abc\" type=\"button\">Télécharger le .abc</button>
        </div>
      `;
    document.querySelector('.card').appendChild(viewer);
    const audioControlsHost = viewer.querySelector('#audio-controls');
    const audioSettingsWrap = document.createElement('div');
    audioSettingsWrap.id = 'audio-settings';
    audioSettingsWrap.style.cssText = 'margin-top:10px;display:flex;gap:12px;flex-wrap:wrap;align-items:center;';
    audioSettingsWrap.innerHTML = [
      '<label class="hint" style="display:flex;flex-direction:column;gap:4px;min-width:190px;">',
      '<span>Instrument</span>',
      '<select id="instrument-select" style="padding:6px;border-radius:6px;background:#0e1533;color:#c8d1ff;border:1px solid #394380;">',
      '<option value="bagpipe" selected>Cornemuse (GHB)</option>',
      '<option value="default">Instrument d\'origine</option>',
      '</select>',
      '</label>',
      '<label class="hint" for="ornament-range" style="display:flex;flex-direction:column;gap:4px;min-width:220px;">',
      '<span>Duree des ornements</span>',
      '<input type="range" id="ornament-range" min="0.05" max="0.20" step="0.01" value="0.1" style="width:200px;" />',
      '</label>',
      '<span id="ornament-value" class="hint">10 % de la note</span>'
    ].join('');
    if (audioControlsHost && audioControlsHost.parentNode) {
      audioControlsHost.insertAdjacentElement('afterend', audioSettingsWrap);
    } else {
      viewer.appendChild(audioSettingsWrap);
    }
    const instrumentSelect = viewer.querySelector('#instrument-select');
    const ornamentRange = viewer.querySelector('#ornament-range');
    const ornamentValue = viewer.querySelector('#ornament-value');

    const applyOrnamentFraction = (nextValue) => {
      const clamped = clampGraceFraction(nextValue);
      audioState.graceFraction = clamped;
      if (ornamentRange) {
        const current = Number.parseFloat(ornamentRange.value);
        if (Number.isNaN(current) || Math.abs(current - clamped) > 1e-3) {
          ornamentRange.value = String(clamped);
        }
      }
      if (ornamentValue) {
        ornamentValue.textContent = formatOrnamentFraction(clamped);
      }
      return clamped;
    };

    if (instrumentSelect) {
      audioState.instrument = instrumentSelect.value || audioState.instrument;
      instrumentSelect.addEventListener('change', () => {
        audioState.instrument = instrumentSelect.value;
        scheduleSynthRefresh();
      });
    }

    if (ornamentRange) {
      applyOrnamentFraction(audioState.graceFraction);
      ornamentRange.addEventListener('input', (event) => {
        const raw = Number(event.target.value);
        if (!Number.isNaN(raw)) {
          applyOrnamentFraction(raw);
          scheduleSynthRefresh();
        }
      });
      ornamentRange.addEventListener('change', () => {
        scheduleSynthRefresh();
      });
    } else if (ornamentValue) {
      ornamentValue.textContent = formatOrnamentFraction(audioState.graceFraction);
    }

    // Ajout dynamique du bouton Imprimer à côté de Télécharger
    try {
      const dlParent = document.getElementById('download-abc')?.parentNode;
      if (dlParent && !document.getElementById('print-abc')) {
        const printBtn = document.createElement('button');
        printBtn.className = 'btn';
        printBtn.id = 'print-abc';
        printBtn.type = 'button';
        printBtn.textContent = 'Imprimer';
        dlParent.appendChild(printBtn);
      }
    } catch { }

    // Convertit <pre id="abc-code"> en <textarea id="abc-code" class="abc-editor"> et ajoute un bouton Mettre à jour
    try {
      const codeEl = document.getElementById('abc-code');
      if (codeEl && codeEl.tagName !== 'TEXTAREA') {
        const ta = document.createElement('textarea');
        ta.id = 'abc-code';
        ta.className = 'abc-editor';
        ta.placeholder = 'Éditez ici le code ABC...';
        ta.value = codeEl.textContent || '';
        codeEl.replaceWith(ta);
      }
      const actions = document.getElementById('download-abc')?.parentNode;
      if (actions && !document.getElementById('update-preview')) {
        const updBtn = document.createElement('button');
        updBtn.className = 'btn';
        updBtn.id = 'update-preview';
        updBtn.type = 'button';
        updBtn.textContent = 'Mettre à jour';
        actions.insertBefore(updBtn, actions.firstChild);
      }
    } catch { }

    pickBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", (e) => addFiles(e.target.files));

    ["dragenter", "dragover"].forEach((ev) =>
      drop.addEventListener(ev, (e) => {
        e.preventDefault();
        drop.classList.add("drag");
      })
    );
    ["dragleave", "drop"].forEach((ev) =>
      drop.addEventListener(ev, (e) => {
        e.preventDefault();
        drop.classList.remove("drag");
      })
    );
    drop.addEventListener("drop", (e) => {
      addFiles(e.dataTransfer.files);
    });

    function addFiles(fileList) {
      const incoming = Array.from(fileList).filter((f) =>
        /\.bww$/i.test(f.name)
      );
      files.push(...incoming);
      renderList();
    }

    function renderList() {
      list.innerHTML = "";
      files.forEach((f, i) => {
        const row = document.createElement("div");
        row.className = "item";
        row.innerHTML = `
      <span class="name">${f.name}</span>
      <span class="status" id="st-${i}">en attente</span>
      <button class="btn" data-view-index="${i}" type="button">Voir</button>
    `;
        list.appendChild(row);
      });
      convertBtn.disabled = files.length === 0;

      // Attach per-item view buttons
      list.querySelectorAll('button[data-view-index]').forEach((btn) => {
        btn.addEventListener('click', async (e) => {
          const idx = parseInt(e.currentTarget.getAttribute('data-view-index'), 10);
          if (isNaN(idx) || !files[idx]) return;
          // Convert only this file and preview
          try {
            const fd = new FormData();
            fd.append('files', files[idx], files[idx].name);
            document.getElementById('st-' + idx).textContent = 'conversion...';
            const resp = await fetch('/convert', { method: 'POST', body: fd });
            if (!resp.ok) {
              const err = await safeJson(resp);
              alert('Erreur: ' + (err?.error || resp.statusText));
              return;
            }
            const abcText = await resp.text();
            document.getElementById('st-' + idx).textContent = 'prévisualisé';
            const dlName = files[idx].name.replace(/\.bww$/i, '') + '.abc';
            showAbc(abcText, dlName);
          } catch (e) {
            console.error(e);
            alert('Erreur: ' + e.message);
          }
        });
      });
    }

    // RAZ: clear selection and preview
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        files = [];
        fileInput.value = '';
        list.innerHTML = '';
        convertBtn.disabled = true;
        // Hide viewer
        if (viewer) {
          viewer.style.display = 'none';
          const paper = document.getElementById('paper');
          const audio = document.getElementById('audio-controls');
          if (paper) paper.innerHTML = '';
          if (audio) audio.innerHTML = '';
          const code = document.getElementById('abc-code');
          if (code) {
            if (code.tagName === 'TEXTAREA') code.value = '';
            else code.textContent = '';
          }
        }
      });
    }

    convertBtn.addEventListener("click", async () => {
      if (!files.length) return;
      convertBtn.disabled = true;
      try {
        const fd = new FormData();
        files.forEach((f) => fd.append("files", f, f.name));

        // MAJ statut UI
        files.forEach(
          (_, i) =>
            (document.getElementById("st-" + i).textContent = "envoi…")
        );

        const resp = await fetch("/convert", { method: "POST", body: fd });
        if (!resp.ok) {
          const err = await safeJson(resp);
          alert("Erreur: " + (err?.error || resp.statusText));
          return;
        }

        // Affichage direct si un seul fichier (text/plain)
        {
          const contentTypeHead = resp.headers.get("Content-Type") || "";
          const isZip = contentTypeHead.includes("application/zip");
          if (!isZip) {
            const abcText = await resp.text();
            const dlName = files[0].name.replace(/\.bww$/i, "") + ".abc";
            files.forEach((_, i) => (document.getElementById("st-" + i).textContent = "prévisualisé"));
            showAbc(abcText, dlName);
            return; // ne pas exécuter le flux ZIP
          }
        }

        const blob = await resp.blob();
        // s'il y a 1 fichier côté serveur, il renvoie text/plain; sinon application/zip
        const contentType = resp.headers.get("Content-Type") || "";
        const many = contentType.includes("application/zip");

        const dlName = many
          ? "converted_abc.zip"
          : files[0].name.replace(/\.bww$/i, "") + ".abc";

        // MAJ statut UI
        files.forEach(
          (_, i) =>
            (document.getElementById("st-" + i).textContent = "converti ✔")
        );

        const url = URL.createObjectURL(blob);
        const a = Object.assign(document.createElement("a"), {
          href: url,
          download: dlName,
        });
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (e) {
        console.error(e);
        alert("Erreur: " + e.message);
      } finally {
        convertBtn.disabled = false;
      }
    });

    async function safeJson(resp) {
      try {
        return await resp.json();
      } catch {
        return null;
      }
    }

    function clampGraceFraction(value) {
      const min = 0.05;
      const max = 0.20;
      const numeric = Number(value);
      if (Number.isNaN(numeric)) {
        return 0.1;
      }
      return Math.min(max, Math.max(min, numeric));
    }

    function formatOrnamentFraction(fraction) {
      const percent = Math.round(clampGraceFraction(fraction) * 100);
      return percent + ' % de la note';
    }

    function applyGraceTiming(noteMapTracks, fraction) {
      if (!Array.isArray(noteMapTracks) || noteMapTracks.length === 0) {
        return;
      }
      const target = clampGraceFraction(fraction);
      if (Math.abs(target - 0.5) < 1e-3) {
        return;
      }
      noteMapTracks.forEach((track) => {
        if (!Array.isArray(track) || track.length === 0) {
          return;
        }
        track.sort((a, b) => a.start - b.start);
        const graceGroup = [];
        for (let i = 0; i < track.length; i += 1) {
          const note = track[i];
          if (note.style === 'grace') {
            graceGroup.push(note);
            continue;
          }
          if (graceGroup.length === 0) {
            continue;
          }
          const mainNote = note;
          const groupStart = graceGroup[0].start;
          const graceSpan = mainNote.start - groupStart;
          const mainSpan = mainNote.end - mainNote.start;
          if (graceSpan > 0 && mainSpan > 0) {
            const total = graceSpan + mainSpan;
            const desiredGraceSpan = total * target;
            const desiredMainSpan = total - desiredGraceSpan;
            const scale = desiredGraceSpan / graceSpan;
            let cursor = groupStart;
            graceGroup.forEach((grace) => {
              const baseLength = grace.end - grace.start;
              const scaledLength = baseLength * scale;
              grace.start = cursor;
              grace.end = cursor + scaledLength;
              cursor = grace.end;
            });
            mainNote.start = groupStart + desiredGraceSpan;
            mainNote.end = mainNote.start + desiredMainSpan;
          }
          graceGroup.length = 0;
        }
      });
    }

    function buildAudioParams() {
      const graceFraction = clampGraceFraction(audioState.graceFraction);
      return {
        sequenceCallback: (noteMapTracks) => {
          applyGraceTiming(noteMapTracks, graceFraction);
        },
        options: {
          program: audioState.instrument === 'bagpipe' ? 109 : 0,
          soundFontUrl: DEFAULT_SOUNDFONT_URL,
        },
      };
    }

    function scheduleSynthRefresh() {
      if (!activeVisualObj) {
        return;
      }
      if (ornamentUpdateTimer) {
        clearTimeout(ornamentUpdateTimer);
      }
      ornamentUpdateTimer = setTimeout(() => {
        ornamentUpdateTimer = null;
        setupSynth(activeVisualObj);
      }, 150);
    }

    function setupSynth(visualObj) {
      if (!visualObj || !ABCJS || !ABCJS.synth || !ABCJS.synth.supportsAudio()) {
        return;
      }
      if (ornamentUpdateTimer) {
        clearTimeout(ornamentUpdateTimer);
        ornamentUpdateTimer = null;
      }
      const controls = document.getElementById('audio-controls');
      if (controls) {
        controls.innerHTML = '';
      }
      if (activeSynthControl && typeof activeSynthControl.destroy === 'function') {
        try {
          activeSynthControl.destroy();
        } catch (err) {
          console.warn(err);
        }
      }
      const synthControl = new ABCJS.synth.SynthController();
      synthControl.load('#audio-controls', null, {
        displayPlay: true,
        displayRestart: true,
        displayProgress: true,
        displayClock: true,
      });
      synthControl.setTune(visualObj, false, buildAudioParams()).catch((error) => console.warn(error));
      activeSynthControl = synthControl;
    }

    async function showAbc(abcText, dlName) {
      // Attendre que abcjs soit chargé (local ou CDN)
      try {
        await (window.__loadAbcjsPromise || Promise.reject(new Error('Chargeur abcjs manquant')));
      } catch (e) {
        console.error(e);
        alert("abcjs n'est pas disponible. Verifiez la connexion ou l'installation.");
        return;
      }
      // Affiche la zone viewer
      viewer.style.display = "block";
      const codeEl = document.getElementById("abc-code");
      if (codeEl) {
        if (typeof codeEl.value === 'string') {
          codeEl.value = abcText;
        } else {
          codeEl.textContent = abcText;
        }
      }
      activeAbcSource = abcText;
      activeDownloadName = dlName;

      const paper = document.getElementById("paper");
      if (paper) {
        paper.innerHTML = "";
      }
      const audioContainer = document.getElementById("audio-controls");
      if (audioContainer) {
        audioContainer.innerHTML = "";
      }

      // Rendu de la partition
      if (!window.ABCJS || typeof ABCJS.renderAbc !== 'function') {
        alert("abcjs est charge mais la fonction renderAbc est indisponible. Essayez d'actualiser la page.");
        return;
      }
      const visualObjs = ABCJS.renderAbc("paper", abcText, {
        responsive: "resize",
        add_classes: true,
      });
      activeVisualObj = Array.isArray(visualObjs) ? visualObjs[0] : null;
      applyOrnamentFraction(audioState.graceFraction);

      // Audio controls if supported
      if (ABCJS && ABCJS.synth && ABCJS.synth.supportsAudio() && activeVisualObj) {
        setupSynth(activeVisualObj);
      } else {
        activeSynthControl = null;
      }

      // Download button (.abc)
      const dlBtn = document.getElementById("download-abc");
      if (dlBtn) {
        dlBtn.onclick = () => {
          const blob = new Blob([activeAbcSource || abcText], { type: "text/plain;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = Object.assign(document.createElement("a"), { href: url, download: (activeDownloadName || dlName) });
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        };
      }

      const printBtn = document.getElementById('print-abc');
      if (printBtn) {
        printBtn.onclick = () => {
          const title = (dlName || 'Partition').replace(/\.abc$/i, '');
          const svgHtml = document.getElementById('paper')?.innerHTML || '';
          printPaperInIframe(svgHtml, title);
        };
      }

      // Prépare éditeur (textarea) et actions (update + download sur contenu courant)
      try {
        const editor = document.getElementById('abc-code');
        if (editor && editor.tagName === 'TEXTAREA' && !editor.value) {
          editor.value = abcText;
          editor.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
              e.preventDefault();
              const up = document.getElementById('update-preview');
              if (up) up.click();
            }
          });
        }
        const dl = document.getElementById('download-abc');
        if (dl) {
          dl.onclick = () => {
            const current = (document.getElementById('abc-code')?.value) || abcText;
            activeAbcSource = current;
            activeDownloadName = dlName;
            const blob = new Blob([current], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = Object.assign(document.createElement('a'), { href: url, download: (activeDownloadName || dlName) });
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
          };
        }
        const upd = document.getElementById('update-preview');
        const rerender = () => {
          const updated = (document.getElementById('abc-code')?.value) || abcText;
          const paperEl = document.getElementById('paper');
          if (paperEl) {
            paperEl.innerHTML = '';
          }
          const audioEl = document.getElementById('audio-controls');
          if (audioEl) {
            audioEl.innerHTML = '';
          }
          const objs = ABCJS.renderAbc('paper', updated, { responsive: 'resize', add_classes: true });
          activeAbcSource = updated;
          activeVisualObj = Array.isArray(objs) ? objs[0] : null;
          applyOrnamentFraction(audioState.graceFraction);
          if (ABCJS && ABCJS.synth && ABCJS.synth.supportsAudio() && activeVisualObj) {
            setupSynth(activeVisualObj);
          } else {
            activeSynthControl = null;
          }
        };
        if (upd) {
          upd.onclick = rerender;
        }
        // Live update avec debounce
        if (editor && editor.tagName === 'TEXTAREA') {
          let t = null;
          editor.addEventListener('input', () => {
            if (t) clearTimeout(t);
            t = setTimeout(() => {
              rerender();
            }, 400);
          });
        }
      } catch { }
    }

    function printPaperInIframe(svgHtml, title) {
      if (!svgHtml) {
        alert("Rien à imprimer — la partition n'est pas rendue.");
        return;
      }
      const iframe = document.createElement('iframe');
      iframe.style.position = 'fixed';
      iframe.style.right = '0';
      iframe.style.bottom = '0';
      iframe.style.width = '0';
      iframe.style.height = '0';
      iframe.style.border = '0';
      document.body.appendChild(iframe);

      const doc = iframe.contentDocument || iframe.contentWindow.document;
      const safeTitle = (title || 'Partition').replace(/</g, '&lt;');
      doc.open();
      doc.write(`<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>${safeTitle}</title>
  <style>
    @page { margin: 12mm; }
    html, body { background:#fff; margin:0; padding:0; }
    .paper { margin: 0 auto; }
    svg { width: 100%; height: auto; }
  </style>
</head>
<body>
  <div class="paper">${svgHtml}</div>
</body>
</html>`);
      doc.close();

      const w = iframe.contentWindow;
      // Attendre la mise en page de l'iframe
      setTimeout(() => {
        w.focus();
        w.print();
        // nettoyage après un court délai
        setTimeout(() => iframe.remove(), 200);
      }, 50);
    }
  </script>
</body>

</html>
